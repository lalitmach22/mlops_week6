name: Build and Deploy Iris API to GKE

on:
  push:
    branches:
      - main

# Environment variables available to all jobs and steps
env:
  GCP_PROJECT_ID: mlopsweek1
  GKE_CLUSTER: mlopsweek6
  GKE_ZONE: us-central1-a
  ARTIFACT_REGISTRY: us-central1-docker.pkg.dev
  REPO_NAME: iris-repo
  IMAGE_NAME: iris-api
  MODEL_BUCKET_URI: gs://mlops-course-mlopsweek1-unique/my-models/iris-classifier-week-1/model.joblib

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Prevent runaway jobs

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Sanity check required variables
      run: |
        echo "üîç Performing sanity check on environment variables..."
        for var in GCP_PROJECT_ID GKE_CLUSTER GKE_ZONE ARTIFACT_REGISTRY REPO_NAME IMAGE_NAME MODEL_BUCKET_URI; do
          if [ -z "${!var}" ]; then
            echo "‚ùå Environment variable $var is not set!"
            exit 1
          else
            echo "‚úÖ $var is set"
          fi
        done
        echo "‚úÖ All required environment variables are present"

    - name: Debug - Show environment
      run: |
        echo "üîç Environment Debug Info:"
        echo "GCP_PROJECT_ID: ${{ env.GCP_PROJECT_ID }}"
        echo "GKE_CLUSTER: ${{ env.GKE_CLUSTER }}"
        echo "GKE_ZONE: ${{ env.GKE_ZONE }}"
        echo "ARTIFACT_REGISTRY: ${{ env.ARTIFACT_REGISTRY }}"
        echo "REPO_NAME: ${{ env.REPO_NAME }}"
        echo "IMAGE_NAME: ${{ env.IMAGE_NAME }}"
        echo "MODEL_BUCKET_URI: ${{ env.MODEL_BUCKET_URI }}"
        echo "Working directory: $(pwd)"
        echo "Repository contents:"
        ls -la

    - name: Decode base64 GCP credentials
      run: |
        echo "üîê Decoding GCP credentials..."
        echo "${{ secrets.GCP_SA_KEY_B64 }}" | base64 -d > ${{ github.workspace }}/gcp-key.json
        echo "‚úÖ Credentials file created"
        ls -la ${{ github.workspace }}/gcp-key.json

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: '${{ github.workspace }}/gcp-key.json'

    - name: Debug - Verify GCP authentication
      run: |
        echo "üîç Verifying GCP authentication..."
        gcloud auth list
        gcloud config get-value project
        echo "‚úÖ GCP authentication verified"

    - name: Download Model from GCS
      run: |
        echo "üì• Downloading model from ${{ env.MODEL_BUCKET_URI }}"
        
        # Check if api directory exists
        if [ ! -d "./api" ]; then
          echo "‚ùå api directory not found!"
          echo "Current directory contents:"
          ls -la
          exit 1
        fi
        
        # Download the model
        gcloud storage cp "${{ env.MODEL_BUCKET_URI }}" ./api/model.joblib
        
        # Verify model file exists and is not empty
        if [ ! -s "./api/model.joblib" ]; then
          echo "‚ùå Model file is missing or empty"
          exit 1
        fi
        
        echo "‚úÖ Model downloaded successfully"
        echo "üìä Model file info:"
        ls -la ./api/model.joblib

    - name: Set up GKE credentials
      uses: google-github-actions/get-gke-credentials@v2
      with:
        cluster_name: ${{ env.GKE_CLUSTER }}
        location: ${{ env.GKE_ZONE }}
        project_id: ${{ env.GCP_PROJECT_ID }}

    - name: Debug - Verify kubectl access
      run: |
        echo "üîç Verifying kubectl access..."
        kubectl cluster-info
        kubectl get nodes
        echo "‚úÖ kubectl access verified"

    - name: Configure Docker for Artifact Registry
      run: |
        echo "üê≥ Configuring Docker for Artifact Registry..."
        gcloud auth configure-docker ${{ env.ARTIFACT_REGISTRY }}
        echo "‚úÖ Docker configured for Artifact Registry"

    - name: Debug - Check Docker and api directory
      run: |
        echo "üîç Checking Docker and api directory..."
        docker --version
        echo "API directory contents:"
        ls -la ./api/
        echo "Checking for required files:"
        [ -f "./api/Dockerfile" ] && echo "‚úÖ Dockerfile found" || echo "‚ùå Dockerfile missing"
        [ -f "./api/fastapi.py" ] && echo "‚úÖ fastapi.py found" || echo "‚ùå fastapi.py missing"
        [ -f "./api/requirements.txt" ] && echo "‚úÖ requirements.txt found" || echo "‚ùå requirements.txt missing"
        [ -f "./api/model.joblib" ] && echo "‚úÖ model.joblib found" || echo "‚ùå model.joblib missing"

    - name: Build and Push Docker image
      run: |
        echo "üî® Building Docker image..."
        
        # Use commit SHA for better traceability and avoid latest tag collisions
        IMAGE_TAG_SHA="${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        IMAGE_TAG_LATEST="${{ env.ARTIFACT_REGISTRY }}/${{ env.GCP_PROJECT_ID }}/${{ env.REPO_NAME }}/${{ env.IMAGE_NAME }}:latest"
        
        echo "Building image with tags:"
        echo "  - SHA tag: $IMAGE_TAG_SHA"
        echo "  - Latest tag: $IMAGE_TAG_LATEST"
        
        # Build the image with both tags
        docker build -t "$IMAGE_TAG_SHA" -t "$IMAGE_TAG_LATEST" ./api
        
        echo "üì§ Pushing Docker images..."
        docker push "$IMAGE_TAG_SHA"
        docker push "$IMAGE_TAG_LATEST"
        
        echo "‚úÖ Docker images built and pushed successfully"
        echo "Primary image (SHA): $IMAGE_TAG_SHA"
        echo "Fallback image (latest): $IMAGE_TAG_LATEST"
        
        # Export the SHA tag for use in deployment
        echo "IMAGE_TAG_SHA=$IMAGE_TAG_SHA" >> $GITHUB_ENV

    - name: Deploy to GKE
      run: |
        echo "üöÄ Deploying to GKE..."
        
        # Check if deployment.yaml exists
        if [ ! -f "deployment.yaml" ]; then
          echo "‚ùå deployment.yaml not found!"
          ls -la
          exit 1
        fi
        
        echo "üìã Original deployment file contents:"
        cat deployment.yaml
        
        # Update deployment.yaml to use the specific SHA image tag for traceability
        echo "üîÑ Updating image tag to use SHA: $IMAGE_TAG_SHA"
        sed "s|image: .*|image: $IMAGE_TAG_SHA|g" deployment.yaml > deployment-updated.yaml
        
        echo "üìã Updated deployment file contents:"
        cat deployment-updated.yaml
        
        # Apply the deployment with the updated image
        kubectl apply -f deployment-updated.yaml
        
        echo "‚è≥ Waiting for deployment rollout..."
        kubectl rollout status deployment/iris-api-deployment --timeout=300s
        
        echo "‚úÖ Deployment completed successfully with image: $IMAGE_TAG_SHA"

    - name: Clean up Docker build logs and temporary files
      run: |
        echo "üßπ Cleaning up build artifacts..."
        rm -f deployment-updated.yaml
        docker system prune -f --volumes || true
        echo "‚úÖ Cleanup completed"

    - name: Wait for LoadBalancer and Create CML Report
      env:
        repo_token: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "üìã Installing CML..."
        pip install cml
        
        echo "‚è≥ Waiting for LoadBalancer to get external IP..."
        EXTERNAL_IP=""
        RETRY_COUNT=0
        MAX_RETRIES=12  # 12 retries * 30 seconds = 6 minutes max wait
        
        while [ -z "$EXTERNAL_IP" ] && [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          sleep 30
          EXTERNAL_IP=$(kubectl get service iris-api-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "üîç Attempt $RETRY_COUNT: External IP = '$EXTERNAL_IP'"
          
          # Debug: Show service status
          kubectl get service iris-api-service
        done
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "‚ùå Failed to get external IP after $MAX_RETRIES attempts"
          echo "Service status:"
          kubectl describe service iris-api-service
          exit 1
        fi
        
        echo "‚úÖ External IP obtained: $EXTERNAL_IP"
        
        # Test the API endpoint
        echo "üß™ Testing API health endpoint..."
        HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" "http://$EXTERNAL_IP/health" || echo "000")
        if [ "$HEALTH_CHECK" != "200" ]; then
          echo "‚ö†Ô∏è API health check failed. HTTP status: $HEALTH_CHECK"
          echo "API logs:"
          kubectl logs -l app=iris-api --tail=20
        else
          echo "‚úÖ API health check passed!"
        fi
        
        echo "üìù Creating CML report..."
        echo "## ‚úÖ Deployment Successful" > report.md
        echo " " >> report.md
        echo "A new version of the Iris API has been deployed and is healthy." >> report.md
        echo "- **Commit:** [${GITHUB_SHA::7}](${{ github.event.repository.html_url }}/commit/${{ github.sha }})" >> report.md
        echo "- **Image Tag:** \`$IMAGE_TAG_SHA\`" >> report.md
        echo "- **API Endpoint:** http://$EXTERNAL_IP" >> report.md
        echo "- **Health Status:** $([ "$HEALTH_CHECK" = "200" ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Check logs")" >> report.md
        echo "- **Deployment Time:** $(date -u)" >> report.md
        echo " " >> report.md
        echo "### Test with cURL:" >> report.md
        echo "\`\`\`bash" >> report.md
        echo "curl -X 'POST' 'http://$EXTERNAL_IP/predict' -H 'Content-Type: application/json' -d '{\"sepal_length\": 5.1, \"sepal_width\": 3.5, \"petal_length\": 1.4, \"petal_width\": 0.2}'" >> report.md
        echo "\`\`\`" >> report.md
        echo " " >> report.md
        echo "### Rollback Command (if needed):" >> report.md
        echo "\`\`\`bash" >> report.md
        echo "kubectl rollout undo deployment/iris-api-deployment" >> report.md
        echo "\`\`\`" >> report.md

        # Post the report as a comment on the commit
        cml comment create report.md
        
        echo "‚úÖ CML report created and posted!"

    - name: Cleanup credentials
      if: always()
      run: |
        echo "üßπ Cleaning up credentials..."
        rm -f ${{ github.workspace }}/gcp-key.json
        echo "‚úÖ Cleanup completed"

    # üîê FUTURE ENHANCEMENT: OIDC Authentication
    # To eliminate the need for service account keys, consider using
    # GitHub Actions OIDC with Workload Identity Federation:
    # 
    # 1. Set up Workload Identity Federation in GCP
    # 2. Replace the "Decode base64 GCP credentials" and "Authenticate to Google Cloud" steps with:
    #
    # - name: Authenticate to Google Cloud
    #   uses: google-github-actions/auth@v2
    #   with:
    #     workload_identity_provider: 'projects/PROJECT-NUMBER/locations/global/workloadIdentityPools/POOL-NAME/providers/PROVIDER-NAME'
    #     service_account: 'SERVICE-ACCOUNT-EMAIL'
    #
    # This provides better security by eliminating long-lived credentials.
